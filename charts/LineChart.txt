let chartInstances = {}; // Global variable to store the current chart instance
let FWDlineChartInstance;
let isDrawing = false; // Variable to track if the mouse is being pressed
let debounceTimeout;



export default function createLineChart(datasets, chartName, chartTitle, pointRadius, modalIndex, movingAveragePeriod) {
  const canvasElement = document.getElementById(chartName);

  if (!canvasElement) {
    console.error(`Canvas element with ID "${chartName}" not found.`);
    return null;
  }

  const ctx = canvasElement.getContext("2d");

  if (!ctx) {
    console.error(`Failed to get 2D context for canvas with ID "${chartName}".`);
    return null;
  }

  // Array to store the chart datasets
  const allDatasets = [];

  // Iterate through the datasets
  datasets.forEach((dataset, index) => {
    // Original dataset (solid line)
    const originalDataset = {
      label: dataset.label,  // Original dataset label
      data: dataset.data.map(dataPoint => ({
        x: dataPoint.x,
        y: dataPoint.y,
        originalY: dataPoint.originalY
      })),
      fill: false,
      borderColor: getColorFromPalette(index),  // Unique color for each original dataset
      tension: 0.1,
      pointRadius: pointRadius,
      borderWidth: 1,
      spanGaps: true,
      borderDash: []  // Solid line for the original dataset
    };

    // Add the original dataset to the list of datasets
    allDatasets.push(originalDataset);

    // Check if Moving Average (MA) is enabled and calculated
    if (dataset.smaData && dataset.smaData.length > 0) {
      const maDataset = {
        label: `${dataset.label} (SMA ${movingAveragePeriod})`,  // MA dataset label
        data: dataset.smaData.map(dataPoint => ({
          x: dataPoint.x,
          y: dataPoint.y
        })),
        fill: false,
        borderColor: 'rgba(255, 0, 0, 0.5)',  // Red color for MA
        borderDash: [5, 5],  // Dotted line for MA
        tension: 0.1,
        pointRadius: 0,  // No points for MA
        borderWidth: 2,
        spanGaps: true,
      };

      // Add MA dataset to the list of datasets
      allDatasets.push(maDataset);
    }
  });

  // Log the final datasets passed to the chart
  console.log('Final datasets for Chart.js:', allDatasets);

  // Create the chart
  let chartInstance = new Chart(ctx, {
    type: "line",
    data: {
      labels: datasets[0].data.map(dataPoint => dataPoint.x),  // Use x-values from the first dataset
      datasets: allDatasets  // Pass the original datasets and MAs
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        axis: 'x',
        intersect: false
      },
      scales: {
        x: {
          display: true,
          title: {
            display: true,
            text: "Year",
          },
        },
        y: {
          display: true,
          title: {
            display: true,
            text: "Value",
          },
        },
      },
      plugins: {
        tooltip: {
          enabled: true,
          callbacks: {
            label: function(context) {
              const originalValue = context.raw ? context.raw.originalY : null;
              return `${context.dataset.label}: ${typeof originalValue === 'number' ? originalValue.toFixed(2) : 'N/A'}`;
            }
          }
        },
        zoom: {
          pan: {
            enabled: true,
            mode: 'x',
          },
          zoom: {
            wheel: {
              enabled: true,
            },
            pinch: {
              enabled: true,
            },
            mode: 'x',
          },
        },
      }
    }
  });

  // Setup chart buttons if applicable
  setupChartButtons(chartInstance, datasets, modalIndex);

  return chartInstance;
}


















let chartInstances = {}; // Global variable to store the current chart instance
let FWDlineChartInstance;
let isDrawing = false; // Variable to track if the mouse is being pressed
let debounceTimeout;



export default function createLineChart(datasets, chartName, chartTitle, pointRadius, modalIndex, movingAveragePeriod) {
  const canvasElement = document.getElementById(chartName);

  if (!canvasElement) {
    console.error(`Canvas element with ID "${chartName}" not found.`);
    return null;
  }

  const ctx = canvasElement.getContext("2d");

  // Array to store both original datasets and their corresponding MAs
  const allDatasets = [];

  // Iterate over all selected datasets
  datasets.forEach((dataset, index) => {
    // Original dataset (solid line)
    const originalDataset = {
      label: dataset.label,  // Original dataset label
      data: dataset.data.map(dataPoint => ({
        x: dataPoint.x,
        y: dataPoint.y,
        originalY: dataPoint.originalY
      })),
      fill: false,
      borderColor: getColorFromPalette(index),  // Assign unique color for each dataset
      tension: 0.1,
      pointRadius: pointRadius,
      borderWidth: 1,
      spanGaps: true,
      borderDash: []  // Solid line for original dataset
    };

    // Add the original dataset to the array
    allDatasets.push(originalDataset);

    // Check if Moving Average (MA) is calculated and exists
    if (dataset.smaData && dataset.smaData.length > 0) {
      const maDataset = {
        label: `${dataset.label} (SMA ${movingAveragePeriod})`,  // MA dataset label
        data: dataset.smaData.map(dataPoint => ({
          x: dataPoint.x,
          y: dataPoint.y
        })),
        fill: false,
        borderColor: 'rgba(255, 0, 0, 0.5)',  // Red color for MA
        borderDash: [5, 5],  // Dotted line for MA
        tension: 0.1,
        pointRadius: 0,  // No points for MA
        borderWidth: 2,
        spanGaps: true,
      };

      // Add the MA dataset to the array
      allDatasets.push(maDataset);
    }
  });

  // Log the datasets to verify they are correct
  console.log('Final datasets for Chart.js:', allDatasets);

  // Create the chart
  let chartInstance = new Chart(ctx, {
    type: "line",
    data: {
      labels: datasets[0].data.map(dataPoint => dataPoint.x),  // Use x-values from the first dataset
      datasets: allDatasets  // Pass the original datasets and MAs
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        axis: 'x',
        intersect: false
      },
      scales: {
        x: {
          display: true,
          title: {
            display: true,
            text: "Year",
          },
        },
        y: {
          display: true,
          title: {
            display: true,
            text: "Value",
          },
        },
      },
      plugins: {
        tooltip: {
          enabled: true,
          callbacks: {
            label: function(context) {
              const originalValue = context.raw ? context.raw.originalY : null;
              return `${context.dataset.label}: ${typeof originalValue === 'number' ? originalValue.toFixed(2) : 'N/A'}`;
            }
          }
        },
        zoom: {
          pan: {
            enabled: true,
            mode: 'x',
          },
          zoom: {
            wheel: {
              enabled: true,
            },
            pinch: {
              enabled: true,
            },
            mode: 'x',
          },
        },
      }
    }
  });

  return chartInstance;
}















function setupChartButtons(chartInstance, datasets, modalIndex) {
  const filteredDatasetsCopy = JSON.parse(JSON.stringify(datasets));

  // Function to get the maximum available years for each dataset
  function getMaxYearsAvailable() {
    let maxYearsAvailable = 0;
    filteredDatasetsCopy.forEach((dataset) => {
      if (!dataset || !dataset.data) return;

      // Find the first and last non-NaN data points
      const firstValidIndex = dataset.data.findIndex(({ y }) => y !== null && !isNaN(y));
      const lastValidIndex = dataset.data.length - 1 - [...dataset.data].reverse().findIndex(({ y }) => y !== null && !isNaN(y));

      if (firstValidIndex !== -1 && lastValidIndex !== -1) {
        const firstDate = parseDateString(dataset.data[firstValidIndex].x);
        const lastDate = parseDateString(dataset.data[lastValidIndex].x);
        const yearsAvailable = (lastDate - firstDate) / (1000 * 60 * 60 * 24 * 365.25); // Convert ms to years

        maxYearsAvailable = Math.max(maxYearsAvailable, yearsAvailable);
      }
    });

    return maxYearsAvailable;
  }

  function filterDataByTimeRange(yearsBack) {
    const maxYearsAvailable = getMaxYearsAvailable();
    const actualYearsBack = Math.min(yearsBack, maxYearsAvailable); // Use the smaller of the two

    const today = new Date();
    const targetDate = new Date(today.setFullYear(today.getFullYear() - actualYearsBack));

    console.log(`Target date for ${actualYearsBack} years back:`, targetDate);

    const filteredDatasets = JSON.parse(JSON.stringify(filteredDatasetsCopy));

    filteredDatasets.forEach((dataset) => {
      if (!dataset || !dataset.data) return;

      console.log(`Original dataset length for ${dataset.label}:`, dataset.data.length);

      // Filter the data based on the target date
      dataset.data = dataset.data.filter(dataPoint => {
        const dataDate = parseDateString(dataPoint.x);
        return dataDate >= targetDate;
      });

      console.log(`Filtered dataset length for ${dataset.label}:`, dataset.data.length);

      //dataset.data = dynamicNormalization(dataset);
    });

    chartInstance.data.labels = filteredDatasets[0]?.data.map(dataPoint => dataPoint.x) || [];
    chartInstance.data.datasets.forEach((dataset, index) => {
      dataset.data = filteredDatasets[index]?.data || [];
    });

    chartInstance.update();
  }

  function bindButton(buttonId, yearsBack) {
    const button = document.getElementById(buttonId);
    if (!button) {
      console.error(`Button with ID ${buttonId} not found.`);
      return;
    }
    button.replaceWith(button.cloneNode(true));
    const newButton = document.getElementById(buttonId);
    newButton.addEventListener('click', () => {
      chartInstance.resetZoom();
      filterDataByTimeRange(yearsBack);
    });
  }

  // Bind buttons with the appropriate year ranges
  bindButton(`oneYearButton_${modalIndex}`, 1);
  bindButton(`fiveYearButton_${modalIndex}`, 5);
  bindButton(`tenYearButton_${modalIndex}`, 10);
  bindButton(`maxButton_${modalIndex}`, 50); // Use a large number to cover the full range

  // Default to a 5-year view
  filterDataByTimeRange(5);
}

















// Function to parse 'dd-mm-yyyy' format into a valid Date object
function parseDateString(dateString) {
  const [day, month, year] = dateString.split('-').map(Number);
  return new Date(year, month - 1, day); // month is 0-indexed in JS Date
}

// Function to get color from the color palette based on the index
function getColorFromPalette(index) {
  const colorPalette = [
    "rgba(255, 255, 0, 1)",     // Bright Yellow
    "rgba(255, 87, 34, 1)",     // Bright Red-Orange
    "rgba(255, 193, 7, 1)",     // Bright Yellow-Orange
    "rgba(0, 255, 255, 1)",     // Bright Cyan
    "rgba(173, 255, 47, 1)",    // Bright Green
    "rgba(255, 105, 180, 1)",   // Hot Pink
    "rgba(75, 0, 130, 1)",      // Indigo
    "rgba(255, 140, 0, 1)",     // Dark Orange
    "rgba(0, 191, 255, 1)",     // Deep Sky Blue
    "rgba(50, 205, 50, 1)",     // Lime Green
  ];

  // Wrap around the palette if the index exceeds its length
  return colorPalette[index % colorPalette.length];
}



function enableCrosshairOnMousePress(canvasElement, chartInstance, initialData) {
  // Add a mousedown event listener to start drawing when the mouse button is pressed
  canvasElement.addEventListener('mousedown', (event) => {
    isDrawing = true;
    drawCrosshair(event, chartInstance, initialData); // Initial drawing
  });

  // Add a mousemove event listener to draw the crosshair while the button is pressed
  canvasElement.addEventListener('mousemove', (event) => {
    if (isDrawing) {
      drawCrosshair(event, chartInstance, initialData);
    }
  });

  // Add a mouseup event listener to stop drawing and clear the crosshair when the button is released
  canvasElement.addEventListener('mouseup', () => {
    isDrawing = false;
    chartInstance.render(); // Clear crosshair and redraw chart without it
  });

  // Add a mouseout event listener to stop drawing when the mouse leaves the canvas
  canvasElement.addEventListener('mouseout', () => {
    isDrawing = false;
    chartInstance.render(); // Clear crosshair and redraw chart without it
  });
}

function drawCrosshair(event, chartInstance, initialData) {
  clearTimeout(debounceTimeout); // Clear any pending renders
  
  debounceTimeout = setTimeout(() => {
    const canvasPosition = Chart.helpers.getRelativePosition(event, chartInstance);
    const x = canvasPosition.x;

    const ctx = chartInstance.ctx;
    const topY = chartInstance.scales.y.top;
    const bottomY = chartInstance.scales.y.bottom;
    const chartWidth = chartInstance.width;

    // Save the canvas state before drawing
    ctx.save();

    // Clear only the area where the crosshair and boxes will be drawn
    ctx.clearRect(0, 0, chartInstance.width, chartInstance.height);
    chartInstance.draw(); // Redraw chart elements

    // Draw the crosshair line (no need to redraw the entire chart)
    ctx.setLineDash([5, 5]); // Dashed line style
    ctx.beginPath();
    ctx.moveTo(x, topY);
    ctx.lineTo(x, bottomY);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#fff'; // White dashed line
    ctx.stroke();
    ctx.setLineDash([]); // Reset dashed line

    let lastBoxY = null; // To track the last box position and avoid overlap
    let nearestDate = null; // To track the nearest date for the bottom box

    // **Optimization**: Reduce redundant searches for nearest points
    let nearestPoints = [];

    // Loop through datasets and cache nearest data points to improve speed
    chartInstance.data.datasets.forEach((dataset, datasetIndex) => {
      if (!chartInstance.isDatasetVisible(datasetIndex)) {
        return; // Skip if the dataset is hidden
      }

      let nearestDataPoint = null;
      let minDistance = Infinity;

      dataset.data.forEach((dataPoint) => {
        const dataPointX = chartInstance.scales.x.getPixelForValue(dataPoint.x);
        const distance = Math.abs(dataPointX - x);

        if (distance < minDistance) {
          minDistance = distance;
          nearestDataPoint = {
            x: dataPointX,
            y: chartInstance.scales.y.getPixelForValue(dataPoint.y),
            date: dataPoint.x,
            originalData: initialData[datasetIndex]?.originalData?.find(d => d.x === dataPoint.x) || null
          };
        }
      });

      if (nearestDataPoint) {
        nearestPoints.push({ datasetIndex, nearestDataPoint });
      }
    });

    // Draw each dataset's box for the nearest points
    nearestPoints.forEach(({ datasetIndex, nearestDataPoint }) => {
      const originalValue = nearestDataPoint.originalData?.y ?? 'N/A';
      const text = `${chartInstance.data.datasets[datasetIndex].label}: ${originalValue}`;

      const textWidth = ctx.measureText(text).width;

      // Determine box position
      let boxX = x + 15;
      let boxY = nearestDataPoint.y - 20;

      // Prevent box from going off the right edge
      if (boxX + textWidth + 20 > chartWidth) {
        boxX = chartWidth - textWidth - 20; // Shift box to the left
      }

      // Prevent box from going below the bottom of the chart
      if (boxY + 30 > bottomY) {
        boxY = bottomY - 30;
      }

      // Stack boxes to avoid overlap
      if (lastBoxY !== null && Math.abs(boxY - lastBoxY) < 30) {
        boxY = lastBoxY - 30; // Stack upwards
      }

      // Ensure boxes stay within the top of the chart
      if (boxY < topY) {
        boxY = topY + 10;
      }

      // Draw the text (no box background)
      ctx.fillStyle = '#fff'; // White text color
      ctx.fillText(text, boxX, boxY + 15);

      lastBoxY = boxY;
      nearestDate = nearestDataPoint.date; // Track the nearest date
    });

    // Draw the date box at the bottom of the chart
    if (nearestDate) {
      const dateText = `Date: ${nearestDate}`;
      const dateTextWidth = ctx.measureText(dateText).width;

      let dateBoxX = Math.min(x + 15, chartWidth - dateTextWidth - 20);
      let dateBoxY = lastBoxY !== null ? lastBoxY - 30 : bottomY - 30;

      if (dateBoxY + 30 > bottomY) {
        dateBoxY = bottomY - 30;
      }

      ctx.fillStyle = '#fff'; // White text color
      ctx.fillText(dateText, dateBoxX, dateBoxY + 15);
    }

    // Restore the canvas state after drawing
    ctx.restore();
  }, 20); // Reduced debounce to 20ms for faster responsiveness
}



export function createFWDLineChart(datasets, chartName, chartTitle, pointRadius) {
  const canvas = document.getElementById(chartName);

  // Clear existing event listeners and destroy the previous chart instance, if it exists
  if (FWDlineChartInstance) {
    FWDlineChartInstance.destroy();
  }

  const newCanvas = canvas.cloneNode(true);
  canvas.parentNode.replaceChild(newCanvas, canvas);

  var ctx = newCanvas.getContext("2d");
  Chart.defaults.font.color = "rgb(161, 160, 160)";

  // Define a color palette with brighter colors for a dark gray background
  const colorPalette = [
    "rgba(255, 255, 0, 1)",     // Bright Yellow
    "rgba(255, 87, 34, 1)",     // Bright Red-Orange
    "rgba(255, 193, 7, 1)",     // Bright Yellow-Orange
    "rgba(0, 255, 255, 1)",     // Bright Cyan
    "rgba(173, 255, 47, 1)",    // Bright Green
    "rgba(255, 105, 180, 1)",   // Hot Pink
    "rgba(75, 0, 130, 1)",      // Indigo
    "rgba(255, 140, 0, 1)",     // Dark Orange
    "rgba(0, 191, 255, 1)",     // Deep Sky Blue
    "rgba(50, 205, 50, 1)",     // Lime Green
  ];

  const xValues = datasets[0].data.map((dataPoint) => dataPoint.x);

  // Create the chart
  FWDlineChartInstance = new Chart(ctx, {
    type: "line",
    data: {
      labels: xValues,
      datasets: datasets.map((dataset, index) => ({
        label: dataset.label,
        data: dataset.data,
        fill: false,
        borderColor: colorPalette[index % colorPalette.length], // Assign a color from the color palette
        tension: 0.1,
        pointRadius: pointRadius,
        borderWidth: 1,
      })),
    },
    options: {
      responsive: true,
      scales: {
        x: {
          display: true,
          title: {
            display: true,
            text: "Year",
            color: "rgb(161, 160, 160)",
          },
          ticks: {
            color: "rgb(161, 160, 160)",
          },
          grid: {
            color: "rgb(90, 90, 90)",
          },
        },
        y: {
          display: true,
          title: {
            display: true,
            text: "Rate (%)",
            color: "rgb(161, 160, 160)",
          },
          ticks: {
            color: "rgb(161, 160, 160)",
          },
          grid: {
            color: "rgb(90, 90, 90)",
          },
        },
      },
      plugins: {
        annotation: {},  // Ensure annotations are disabled completely
        zoom: {
          pan: {
            enabled: true,
            mode: 'x',  // Enable panning on the x-axis
          },
          zoom: {
            wheel: {
              enabled: true,  // Enable zooming with mouse wheel
            },
            pinch: {
              enabled: true,  // Enable zooming with pinch gestures
            },
            mode: 'x',  // Zoom in only on the x-axis
          }
        }
      },
    },
  });

  return FWDlineChartInstance; // Return the created chart instance
}

export function createCSLineChart(data, chartConfig) {
  const ctx = document.getElementById('CS_ChartCanvas').getContext('2d');
  const lineChart = new Chart(ctx, {
    type: 'line',
    data: data,
    options: chartConfig,
  });
}

export function createForwardSwapChart(datasets, chartName, chartTitle, pointRadius) {
  const canvas = document.getElementById(chartName);

  // Clear existing event listeners and destroy the previous chart instance, if it exists
  if (window.forwardSwapChartInstance) {
    window.forwardSwapChartInstance.destroy();
  }

  const newCanvas = canvas.cloneNode(true);
  canvas.parentNode.replaceChild(newCanvas, canvas);

  var ctx = newCanvas.getContext("2d");
  Chart.defaults.font.color = "rgb(161, 160, 160)";

  // Define a color palette for the forward swap curve chart
  const colorPalette = [
    "rgba(255, 255, 0, 1)",     // Bright Yellow
    "rgba(255, 87, 34, 1)",     // Bright Red-Orange
    "rgba(255, 193, 7, 1)",     // Bright Yellow-Orange
    "rgba(0, 255, 255, 1)",     // Bright Cyan
    "rgba(173, 255, 47, 1)",    // Bright Green
    "rgba(255, 105, 180, 1)",   // Hot Pink
    "rgba(75, 0, 130, 1)",      // Indigo
    "rgba(255, 140, 0, 1)",     // Dark Orange
    "rgba(0, 191, 255, 1)",     // Deep Sky Blue
    "rgba(50, 205, 50, 1)",     // Lime Green
  ];

  // Create the forward swap chart
  window.forwardSwapChartInstance = new Chart(ctx, {
    type: "line",
    data: {
      labels: datasets[0].data.map(dataPoint => dataPoint.x),  // Use the years for the labels from the first dataset
      datasets: datasets.map((dataset, index) => ({
        label: dataset.label,
        data: dataset.data,
        fill: false,
        borderColor: colorPalette[index % colorPalette.length], // Assign a color from the color palette
        tension: 0.1,
        pointRadius: pointRadius,
        borderWidth: 1,
      })),
    },
    options: {
      responsive: true,
      scales: {
        x: {
          display: true,
          title: {
            display: true,
            text: "Year",
            color: "rgb(161, 160, 160)",
          },
          ticks: {
            color: "rgb(161, 160, 160)",
          },
          grid: {
            color: "rgb(90, 90, 90)",
          },
        },
        y: {
          display: true,
          title: {
            display: true,
            text: "Rate (%)",
            color: "rgb(161, 160, 160)",
          },
          ticks: {
            color: "rgb(161, 160, 160)",
          },
          grid: {
            color: "rgb(90, 90, 90)",
          },
        },
      },
      plugins: {
        annotation: {},  // Ensure annotations are disabled completely
        zoom: {
          pan: {
            enabled: true,
            mode: 'x',  // Enable panning on the x-axis
          },
          zoom: {
            wheel: {
              enabled: true,  // Enable zooming with mouse wheel
            },
            pinch: {
              enabled: true,  // Enable zooming with pinch gestures
            },
            mode: 'x',  // Zoom in only on the x-axis
          }
        }
      },
    },
  });

  return window.forwardSwapChartInstance; // Return the created chart instance
}

export function createRatesLineChart(datasets, chartName, chartTitle, pointRadius) {
  var ctx = document.getElementById(chartName).getContext("2d");
  Chart.defaults.font.color = "rgb(161, 160, 160)";

  // Define a color palette with fixed colors
  const colorPalette = [
    "rgba(255, 255, 0, 1)",     // Bright Yellow
    "rgba(255, 87, 34, 1)",     // Bright Red-Orange
    "rgba(255, 193, 7, 1)",     // Bright Yellow-Orange
    "rgba(0, 255, 255, 1)",     // Bright Cyan
    "rgba(173, 255, 47, 1)",    // Bright Green
    "rgba(255, 105, 180, 1)",   // Hot Pink
    "rgba(75, 0, 130, 1)",      // Indigo
    "rgba(255, 140, 0, 1)",     // Dark Orange
    "rgba(0, 191, 255, 1)",     // Deep Sky Blue
    "rgba(50, 205, 50, 1)",     // Lime Green
  ];
  

  const xValues = datasets[0].data.map((dataPoint) => dataPoint.x);

  // Create the chart and store it in a variable
  const chart = new Chart(ctx, {
    type: "line",
    data: {
      labels: xValues,
      datasets: datasets.map((dataset, index) => ({
        label: dataset.label,
        data: dataset.data,
        fill: false,
        borderColor: colorPalette[index % colorPalette.length], // Assign a color from the color palette
        tension: 0.1,
        pointRadius: pointRadius,
        borderWidth: 1,
      })),
    },
    options: {
      responsive: true,
      scales: {
        x: {
          display: true,
          title: {
            display: true,
            text: "Year",
            color: "rgb(161, 160, 160)",
          },
          ticks: {
            color: "rgb(161, 160, 160)",
          },
          grid: {
            color: "rgb(90, 90, 90)",
          },
        },
        y: {
          display: true,
          title: {
            display: true,
            text: "Rate (%)",
            color: "rgb(161, 160, 160)",
          },
          ticks: {
            color: "rgb(161, 160, 160)",
          },
          grid: {
            color: "rgb(90, 90, 90)",
          },
          legend: {
            labels: {
              color: "rgb(161, 160, 160)",
            },
          },
        },
      },
      plugins: {
        zoom: {
          pan: {
            enabled: true,
            mode: 'x',
            threshold: 10,
          },
          zoom: {
            drag:{
              enabled: true
            },
            wheel: {
              enabled: true,
            },
            pinch: {
              enabled: true,
            },
            mode: 'x',
          },
          limits: {
            x: { minRange: 1 },
          },
        },
      },
    },
  });

  // // Range selector input
  // const rangeSelector = document.createElement("input");
  // rangeSelector.type = "range";
  // rangeSelector.min = 0;
  // rangeSelector.max = xValues.length - 1;
  // rangeSelector.value = xValues.length - 1;
  // rangeSelector.style.width = "100%";
  // rangeSelector.addEventListener("input", () => {
  //   const startIdx = Math.max(0, xValues.length - parseInt(rangeSelector.value, 10));
  //   const endIdx = xValues.length - 1;
  //   chart.options.scales.x.min = xValues[startIdx];
  //   chart.options.scales.x.max = xValues[endIdx];
  //   chart.update("none");
  // });

  // Append the range selector input to the chart container
  //document.getElementById(chartName).parentNode.appendChild(rangeSelector);

  return chart; // Return the created chart instance
}

export function futurePredictionsChart(datasets, chartName, chartTitle, pointRadius) {
  const ctx = document.getElementById(chartName).getContext("2d");

  // Extract x-values for the labels
  const xValues = datasets[0].data.map((dataPoint) => dataPoint.x);

  // Create the chart
  new Chart(ctx, {
      type: "line",
      data: {
          labels: xValues,  // Use x values as labels
          datasets: datasets.map((dataset, index) => ({
              label: dataset.label,
              data: dataset.data.map(point => point.y),  // Use y values as the dataset
              fill: false,
              borderColor: "rgba(75, 192, 192, 1)",  // Example color
              tension: 0.1,
              pointRadius: pointRadius,
              borderWidth: 1,
          })),
      },
      options: {
          responsive: true,
          plugins: {
              legend: {
                  display: true,
                  labels: {
                      color: "rgb(161, 160, 160)"
                  }
              }
          },
          scales: {
              x: {
                  display: true,
                  title: {
                      display: true,
                      text: "Index",
                      color: "rgb(161, 160, 160)",
                  },
                  ticks: {
                      color: "rgb(161, 160, 160)",
                  },
                  grid: {
                      color: "rgb(90, 90, 90)",
                  },
              },
              y: {
                  display: true,
                  title: {
                      display: true,
                      text: "Predictions",
                      color: "rgb(161, 160, 160)",
                  },
                  ticks: {
                      color: "rgb(161, 160, 160)",
                  },
                  grid: {
                      color: "rgb(90, 90, 90)",
                  },
              },
          },
      },
  });
}
export function MLTestDataChart(datasets, chartName, chartTitle, pointRadius) {
  const canvas = document.getElementById(chartName);
  if (!canvas) {
    console.error(`Canvas with ID ${chartName} not found`);
    return;
  }

  const ctx = canvas.getContext("2d");

  if (!datasets || !datasets.length || !datasets[0].data || !datasets[0].data.length) {
    console.error("Invalid dataset provided for chart:", datasets);
    return;
  }

  // Extract x-values (formatted date strings) for the labels
  const xValues = datasets[0].data.map(dataPoint => dataPoint.x);

  const colors = {
    train: "rgba(0, 123, 255, 1)",  // Blue for Train Data
    test: "rgba(75, 192, 192, 1)",  // Cyan for Test Data
    predictions: "rgba(255, 99, 132, 1)",  // Red for Predictions
    future: "rgba(255, 206, 86, 1)",  // Yellow for Future Predictions
  };

  const lineStyles = {
    solid: [],  // Solid line
    dashed: [5, 5],  // Dashed line for future predictions
  };

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: xValues,  // Use formatted date strings for labels
      datasets: datasets.map((dataset) => {
        let color, borderDash;
        if (dataset.label === 'Train Data') {
          color = colors.train;
          borderDash = lineStyles.solid;
        } else if (dataset.label === 'Test Data') {
          color = colors.test;
          borderDash = lineStyles.solid;
        } else if (dataset.label === 'Predictions') {
          color = colors.predictions;
          borderDash = lineStyles.solid;
        } else if (dataset.label === 'Future Predictions') {
          color = colors.future;
          borderDash = lineStyles.dashed;
        }

        return {
          label: dataset.label,
          data: dataset.data.map(point => ({ x: point.x, y: point.y })),  // Use string dates
          fill: false,
          borderColor: color,
          borderDash: borderDash,
          tension: 0.1,
          pointRadius: pointRadius,
          borderWidth: 1,
        };
      }),
    },
    options: {
      responsive: true,
      plugins: {
        legend: {
          display: true,
          labels: {
            color: 'rgb(161, 160, 160)',
          },
        },
        zoom: {
          pan: {
            enabled: true,
            mode: 'x',  // Enable horizontal panning
          },
          zoom: {
            wheel: {
              enabled: true,  // Enable zooming with the mouse wheel
            },
            pinch: {
              enabled: true,  // Enable zooming with pinch gestures on touch devices
            },
            mode: 'x',  // Only allow zooming on the x-axis
          },
        },
      },
      scales: {
        x: {
          display: true,
          title: {
            display: true,
            text: 'Date',
            color: 'rgb(161, 160, 160)',
          },
          ticks: {
            color: 'rgb(161, 160, 160)',
            callback: function(value, index, values) {
              // Shorten the x-axis to only show important date points
              return value;  // Show full date labels
            }
          },
          grid: {
            color: 'rgb(90, 90, 90)',
          },
        },
        y: {
          display: true,
          title: {
            display: true,
            text: 'Values',
            color: 'rgb(161, 160, 160)',
          },
          ticks: {
            color: 'rgb(161, 160, 160)',
          },
          grid: {
            color: 'rgb(90, 90, 90)',
          },
        },
      },
    },
  });
}